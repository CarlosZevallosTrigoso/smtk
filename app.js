// 游댷游댷游댷 Pega aqu칤 la URL de tu servidor de Render 游댷游댷游댷
const socket = io('https://smtk-server.onrender.com');

// --- Referencias a elementos del DOM ---
const messagesDiv = document.getElementById('messages');
const senderInputDiv = document.getElementById('sender-input');
const readerInputDiv = document.getElementById('reader-input');
const messageInput = document.getElementById('message-input');
const passwordInput = document.getElementById('password-input');
const sendButton = document.getElementById('send-button');
const decryptPasswordInput = document.getElementById('decrypt-password-input');
const decryptButton = document.getElementById('decrypt-button');

let peer;
let myRole; // Guardar치 si somos 'fa' o 'fb'
let currentEncryptedPayload = null; // Para almacenar el 칰ltimo mensaje encriptado recibido
let currentPayloadId = null; // ID 칰nico para el payload

// --- Inicializaci칩n y manejo de roles ---
window.onload = () => {
    const hash = location.hash.substring(1); // Obtiene 'fa' o 'fb' de la URL
    if (hash === 'fa') {
        myRole = 'fa';
        senderInputDiv.style.display = 'flex'; // Mostrar interfaz de emisor
        displayMessage('System: Rol asignado: fa (Emisor). Esperando conexi칩n...');
    } else if (hash === 'fb') {
        myRole = 'fb';
        readerInputDiv.style.display = 'flex'; // Mostrar interfaz de receptor
        displayMessage('System: Rol asignado: fb (Receptor). Esperando conexi칩n...');
    } else {
        displayMessage('System: URL inv치lida. Usa #fa o #fb al final para asignar un rol.');
        return;
    }

    // Conectar al servidor de se침alizaci칩n
    socket.on('connect', () => {
        displayMessage('System: Conectado al servidor de se침alizaci칩n...');
        setupPeer(myRole === 'fa'); // fa inicia la conexi칩n
    });

    socket.on('signal', (data) => {
        if (!peer) {
            setupPeer(myRole === 'fa');
        }
        peer.signal(data);
    });
};


function setupPeer(initiator) {
    peer = new SimplePeer({
        initiator: initiator,
        trickle: false
    });

    peer.on('signal', (data) => {
        socket.emit('signal', data);
    });

    peer.on('connect', () => {
        displayMessage(`System: Conexi칩n P2P establecida. [user: ${myRole}]`);
        // Limpiar los campos de input al conectar
        messageInput.value = '';
        passwordInput.value = '';
        decryptPasswordInput.value = '';
    });

    // Manejo de datos entrantes
    peer.on('data', async (data) => {
        const parsedData = JSON.parse(new TextDecoder().decode(data));

        if (parsedData.type === 'message') {
            if (myRole === 'fa') {
                // fa no recibe mensajes encriptados, esto no deber칤a pasar
                displayMessage('System: Error - fa recibi칩 un mensaje encriptado inesperado.');
            } else if (myRole === 'fb') {
                // fb recibe un mensaje encriptado
                displayMessage('System: Mensaje encriptado recibido. Introduce la contrase침a para leerlo.');
                currentEncryptedPayload = parsedData.payload; // Guardar el payload encriptado
                currentPayloadId = parsedData.id; // Guardar el ID para la confirmaci칩n
                decryptPasswordInput.focus(); // Enfocar el campo de contrase침a
            }
        } else if (parsedData.type === 'read_confirmation') {
            if (myRole === 'fa') {
                // fa recibe una confirmaci칩n de lectura
                displayMessage(`System: Mensaje [ID: ${parsedData.id.substring(0, 8)}...] le칤do por fb.`, 'read-confirmation');
            }
        }
    });
}

// --- L칩gica de Encriptaci칩n/Desencriptaci칩n por Mensaje ---
async function deriveKey(password, salt) {
    const encoder = new TextEncoder();
    const baseKey = await window.crypto.subtle.importKey(
        'raw', encoder.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
    );
    return window.crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
        baseKey, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']
    );
}

async function encryptMessage(message, password) {
    const salt = window.crypto.getRandomValues(new Uint8Array(16));
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(password, salt);
    const encryptedData = await window.crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv }, key, new TextEncoder().encode(message)
    );
    return {
        salt: Array.from(salt),
        iv: Array.from(iv),
        ciphertext: Array.from(new Uint8Array(encryptedData))
    };
}

async function decryptMessage(payload, password) {
    const salt = new Uint8Array(payload.salt);
    const iv = new Uint8Array(payload.iv);
    const ciphertext = new Uint8Array(payload.ciphertext);
    const key = await deriveKey(password, salt);
    const decryptedData = await window.crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv }, key, ciphertext
    );
    return new TextDecoder().decode(decryptedData);
}

// --- L칩gica de Env칤o (fa) ---
sendButton.addEventListener('click', async () => {
    if (myRole !== 'fa') {
        displayMessage('Error: Solo fa puede enviar mensajes.', 'system-message');
        return;
    }
    const message = messageInput.value;
    const password = passwordInput.value;
    if (message && password && peer && peer.connected) {
        displayMessage(`fa@smtk:~ $ ${message}`); // Muestra el mensaje localmente
        const uniqueId = crypto.randomUUID(); // Genera un ID 칰nico para el mensaje
        const encryptedPayload = await encryptMessage(message, password);

        // Enviar un objeto que indica que es un mensaje y lleva el payload
        peer.send(new TextEncoder().encode(JSON.stringify({
            type: 'message',
            id: uniqueId,
            payload: encryptedPayload
        })));

        messageInput.value = '';
        passwordInput.value = '';
    } else {
        displayMessage('System: Mensaje o contrase침a vac칤os, o no conectado.', 'system-message');
    }
});

// --- L칩gica de Lectura (fb) ---
decryptButton.addEventListener('click', async () => {
    if (myRole !== 'fb') {
        displayMessage('Error: Solo fb puede leer mensajes.', 'system-message');
        return;
    }
    const password = decryptPasswordInput.value;
    if (password && currentEncryptedPayload && peer && peer.connected) {
        try {
            const decrypted = await decryptMessage(currentEncryptedPayload, password);
            displayMessage(`fb@smtk:~ $ ${decrypted}`); // Muestra el mensaje desencriptado
            currentEncryptedPayload = null; // Limpiar mensaje despu칠s de leer
            decryptPasswordInput.value = ''; // Limpiar el campo de contrase침a

            // Enviar confirmaci칩n de lectura a fa
            peer.send(new TextEncoder().encode(JSON.stringify({
                type: 'read_confirmation',
                id: currentPayloadId
            })));
            displayMessage('System: Confirmaci칩n de lectura enviada.', 'read-confirmation');

        } catch (e) {
            displayMessage('Error: Contrase침a incorrecta o mensaje corrupto.', 'system-message');
            console.error('Error al desencriptar:', e);
        }
    } else {
        displayMessage('System: No hay mensaje para leer o contrase침a vac칤a.', 'system-message');
    }
});


// --- Utilidad para mostrar mensajes en la terminal ---
function displayMessage(message, type = '') {
  const p = document.createElement('p');
  p.textContent = message;
  if (type) {
    p.classList.add(type);
  }
  messagesDiv.appendChild(p);
  messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll
}
